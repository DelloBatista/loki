use std::sync::Arc;

use anyhow::{Context as AnyhowContext, Result};
use octocrab::Octocrab;
use serde::{Deserialize, Serialize};
use tracing::{debug, info};

use crate::cognitive::self_modify::{CodeChange, PullRequest};
use crate::memory::{CognitiveMemory, MemoryMetadata};

/// GitHub configuration
#[derive(Debug, Clone)]
pub struct GitHubConfig {
    pub token: String,
    pub owner: String,
    pub repo: String,
    pub default_branch: String,
}

impl GitHubConfig {
    /// Load from environment variables
    pub fn from_env() -> Result<Self> {
        Ok(Self {
            token: std::env::var("GITHUB_TOKEN")
                .context("GITHUB_TOKEN environment variable not set")?,
            owner: std::env::var("GITHUB_OWNER")
                .context("GITHUB_OWNER environment variable not set")?,
            repo: std::env::var("GITHUB_REPO")
                .context("GITHUB_REPO environment variable not set")?,
            default_branch: std::env::var("GITHUB_DEFAULT_BRANCH")
                .unwrap_or_else(|_| "main".to_string()),
        })
    }
}

/// GitHub client with self-modification capabilities
#[derive(Debug)]
pub struct GitHubClient {
    /// Octocrab client
    client: Arc<Octocrab>,

    /// Configuration
    config: GitHubConfig,

    /// Memory system
    memory: Arc<CognitiveMemory>,
}

impl GitHubClient {
    /// Create a new GitHub client
    pub async fn new(config: GitHubConfig, memory: Arc<CognitiveMemory>) -> Result<Self> {
        info!("Initializing GitHub client for {}/{}", config.owner, config.repo);

        let client = Octocrab::builder().personal_token(config.token.clone()).build()?;

        Ok(Self { client: Arc::new(client), config, memory })
    }

    /// Create a pull request from a code change
    pub async fn create_pull_request(
        &self,
        branch_name: String,
        change: CodeChange,
    ) -> Result<PullRequest> {
        info!("Creating PR for branch: {}", branch_name);

        // Create the PR using Octocrab
        let pr = self
            .client
            .pulls(&self.config.owner, &self.config.repo)
            .create(&change.description, &branch_name, &self.config.default_branch)
            .body(&self.format_pr_body(&change))
            .send()
            .await?;

        let pull_request = PullRequest {
            number: pr.number as u32,
            title: change.description.clone(),
            description: self.format_pr_body(&change),
            branch: branch_name,
            status: crate::cognitive::self_modify::PullRequestStatus::Open,
        };

        // Store in memory
        self.memory
            .store(
                format!("Created PR #{}: {}", pr.number, change.description),
                vec![format!("PR URL: {}", pr.html_url.as_ref().map(|u| u.as_str()).unwrap_or(""))],
                MemoryMetadata {
                    source: "github".to_string(),
                    tags: vec!["pull_request".to_string(), "self_modification".to_string()],
                    importance: 0.9,
                    associations: vec![],

                    context: Some("Generated from automated fix".to_string()),
                    created_at: chrono::Utc::now(),
                    accessed_count: 0,
                    last_accessed: None,
                    version: 1,
                    category: "tool_usage".to_string(),
                    timestamp: chrono::Utc::now(),
                    expiration: None,
                },
            )
            .await?;

        Ok(pull_request)
    }

    /// Format PR body with all relevant information
    fn format_pr_body(&self, change: &CodeChange) -> String {
        format!(
            r#"## ðŸ¤– Autonomous Code Change

### Description
{}

### Reasoning
{}

### Risk Level
{:?}

### Change Type
{:?}

### Files Modified
- `{}`

### Generated by Loki
This pull request was automatically generated by the Loki autonomous coding system.

---
*Loki v1 - Building consciousness, one commit at a time*"#,
            change.description,
            change.reasoning,
            change.risk_level,
            change.change_type,
            change.file_path.display()
        )
    }

    /// Get file contents from repository
    pub async fn get_file_contents(&self, path: &str, branch: Option<&str>) -> Result<String> {
        let branch = branch.unwrap_or(&self.config.default_branch);

        debug!("Fetching file contents: {} from branch: {}", path, branch);

        let content = self
            .client
            .repos(&self.config.owner, &self.config.repo)
            .get_content()
            .path(path)
            .r#ref(branch)
            .send()
            .await?;

        if let Some(content) = content.items.first() {
            if let Some(decoded) = content.decoded_content() {
                return Ok(decoded);
            }
        }

        Err(anyhow::anyhow!("Failed to decode file contents"))
    }

    /// List repository files
    pub async fn list_files(&self, path: &str) -> Result<Vec<String>> {
        debug!("Listing files in: {}", path);

        let contents = self
            .client
            .repos(&self.config.owner, &self.config.repo)
            .get_content()
            .path(path)
            .send()
            .await?;

        Ok(contents.items.into_iter().map(|item| item.path).collect())
    }

    /// Check if PR is ready to merge
    pub async fn check_pr_status(&self, pr_number: u32) -> Result<bool> {
        let pr =
            self.client.pulls(&self.config.owner, &self.config.repo).get(pr_number as u64).await?;

        // Check if all checks have passed
        if let Some(mergeable) = pr.mergeable { Ok(mergeable) } else { Ok(false) }
    }

    /// Merge a pull request
    pub async fn merge_pr(&self, pr_number: u32, merge_method: &str) -> Result<()> {
        use octocrab::params::pulls::MergeMethod;

        info!("Merging PR #{} using method: {}", pr_number, merge_method);

        let method = match merge_method {
            "squash" => MergeMethod::Squash,
            "rebase" => MergeMethod::Rebase,
            _ => MergeMethod::Merge,
        };

        self.client
            .pulls(&self.config.owner, &self.config.repo)
            .merge(pr_number as u64)
            .method(method)
            .send()
            .await?;

        // Store in memory
        self.memory
            .store(
                format!("Merged PR #{}", pr_number),
                vec![],
                MemoryMetadata {
                    source: "github".to_string(),
                    tags: vec!["merge".to_string(), "success".to_string()],
                    importance: 0.8,
                    associations: vec![],

                    context: Some("Generated from automated fix".to_string()),
                    created_at: chrono::Utc::now(),
                    accessed_count: 0,
                    last_accessed: None,
                    version: 1,
                    category: "tool_usage".to_string(),
                    timestamp: chrono::Utc::now(),
                    expiration: None,
                },
            )
            .await?;

        Ok(())
    }

    /// Create an issue
    pub async fn create_issue(&self, title: &str, body: &str, labels: Vec<String>) -> Result<u32> {
        let issue = self
            .client
            .issues(&self.config.owner, &self.config.repo)
            .create(title)
            .body(body)
            .labels(labels)
            .send()
            .await?;

        Ok(issue.number as u32)
    }

    /// Get pull request details
    pub async fn get_pull_request(&self, pr_number: u32) -> Result<PullRequestDetails> {
        debug!("Fetching PR #{} details", pr_number);

        let pr = self
            .client
            .pulls(&self.config.owner, &self.config.repo)
            .get(pr_number as u64)
            .await
            .with_context(|| format!("Failed to fetch PR #{}", pr_number))?;

        // Get PR status checks (simplified for now)
        let status = PullRequestStatus::Unknown;

        let pr_details = PullRequestDetails {
            number: pr.number as u32,
            title: pr.title.unwrap_or_default(),
            body: pr.body.unwrap_or_default(),
            state: match pr.state {
                Some(octocrab::models::IssueState::Open) => PRState::Open,
                Some(octocrab::models::IssueState::Closed) => {
                    if pr.merged_at.is_some() {
                        PRState::Merged
                    } else {
                        PRState::Closed
                    }
                }
                None => PRState::Open,    // Default to open if unknown
                Some(_) => PRState::Open, // Catch-all for any other states
            },
            head_branch: pr.head.ref_field,
            base_branch: pr.base.ref_field,
            mergeable: pr.mergeable.unwrap_or(false),
            status_checks: status,
            created_at: pr.created_at.unwrap_or_else(|| chrono::Utc::now()),
            updated_at: pr.updated_at.unwrap_or_else(|| chrono::Utc::now()),
            merged_at: pr.merged_at,
            author: pr
                .user
                .as_ref()
                .map(|u| u.login.clone())
                .unwrap_or_else(|| "unknown".to_string()),
            url: pr.html_url.map(|u| u.to_string()).unwrap_or_else(|| "".to_string()),
        };

        // Store access in memory for tracking
        self.memory
            .store(
                format!("Accessed PR #{}: {}", pr_number, pr_details.title),
                vec![
                    format!("State: {:?}", pr_details.state),
                    format!("Author: {}", pr_details.author),
                    format!("Status: {:?}", pr_details.status_checks),
                ],
                MemoryMetadata {
                    source: "github".to_string(),
                    tags: vec!["pull_request".to_string(), "status_check".to_string()],
                    importance: 0.6,
                    associations: vec![],

                    context: Some("Generated from automated fix".to_string()),
                    created_at: chrono::Utc::now(),
                    accessed_count: 0,
                    last_accessed: None,
                    version: 1,
                    category: "tool_usage".to_string(),
                    timestamp: chrono::Utc::now(),
                    expiration: None,
                },
            )
            .await?;

        Ok(pr_details)
    }

    /// Get repository statistics
    pub async fn get_repo_stats(&self) -> Result<RepoStats> {
        let repo = self.client.repos(&self.config.owner, &self.config.repo).get().await?;

        Ok(RepoStats {
            stars: repo.stargazers_count.unwrap_or(0) as u32,
            forks: repo.forks_count.unwrap_or(0) as u32,
            open_issues: repo.open_issues_count.unwrap_or(0) as u32,
            watchers: repo.watchers_count.unwrap_or(0) as u32,
        })
    }

    /// Comment on a pull request
    pub async fn comment_on_pr(&self, pr_number: u32, comment: &str) -> Result<()> {
        info!("Commenting on PR #{}: {}", pr_number, comment);
        
        // Use the Octocrab client to post a comment on the specified pull request
        self.client
            .issues(&self.config.owner, &self.config.repo)
            .create_comment(pr_number as u64, comment)
            .await
            .context("Failed to create PR comment")?;
            
        // Store the action in memory for tracking
        let metadata = MemoryMetadata {
            source: "github_pr_comment".to_string(),
            tags: vec![
                "github".to_string(),
                "pr".to_string(),
                format!("pr_{}", pr_number),
                "comment".to_string(),
            ],
            importance: 0.7,
            ..Default::default()
        };
        
        self.memory
            .store(
                format!("github_pr_comment_{}", pr_number),
                vec![
                    format!("pr_number: {}", pr_number),
                    format!("comment: {}", comment),
                ],
                metadata,
            )
            .await?;
            
        info!("Successfully commented on PR #{}", pr_number);
        Ok(())
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RepoStats {
    pub stars: u32,
    pub forks: u32,
    pub open_issues: u32,
    pub watchers: u32,
}

/// Detailed pull request information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PullRequestDetails {
    pub number: u32,
    pub title: String,
    pub body: String,
    pub state: PRState,
    pub head_branch: String,
    pub base_branch: String,
    pub mergeable: bool,
    pub status_checks: PullRequestStatus,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    pub merged_at: Option<chrono::DateTime<chrono::Utc>>,
    pub author: String,
    pub url: String,
}

/// Pull request state
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum PRState {
    Open,
    Closed,
    Merged,
}

/// Pull request status check result
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum PullRequestStatus {
    Success,
    Failure,
    Error,
    Pending,
    Unknown,
}
